import { NextResponse } from 'next/server';
import { getPayload } from 'payload';
import configPromise from '@/payload.config';

/**
 * Filter configuration
 */
const FILTER_CONFIG = {
  categories: {
    'AI & Automation': [
      'Zapier', 'Make.com', 'n8n', 'OpenAI', 'ChatGPT', 'AI Tools', 
      'Automation', 'Machine Learning'
    ],
    'Marketing & Growth': [
      'SEMrush', 'Ahrefs', 'Google Analytics', 'Facebook Ads', 'Google Ads',
      'Email Marketing', 'Social Media', 'Content Marketing', 'Growth Hacking'
    ],
    'No-Code/Low-Code': [
      'Bubble', 'Webflow', 'Airtable', 'Notion', 'Framer', 'Carrd', 
      'Ghost', 'WordPress'
    ],
    'Web Development': [
      'React', 'Next.js', 'Vue.js', 'Node.js', 'JavaScript', 'TypeScript',
      'HTML', 'CSS', 'Web Development', 'Frontend', 'Backend', 'Full Stack'
    ]
  },
  skillLevels: ['beginner', 'intermediate', 'advanced']
};

/**
 * Get available filter categories and metadata
 */
export async function GET() {
  try {
    return NextResponse.json({
      success: true,
      data: {
        categories: Object.keys(FILTER_CONFIG.categories).map(category => ({
          name: category,
          slug: category.toLowerCase().replace(/[^a-z0-9]+/g, '-'),
          tools: FILTER_CONFIG.categories[category as keyof typeof FILTER_CONFIG.categories],
          toolCount: FILTER_CONFIG.categories[category as keyof typeof FILTER_CONFIG.categories].length
        })),
        skillLevels: FILTER_CONFIG.skillLevels,
        popularityFilters: [
          { name: 'Popular This Week', slug: 'popular-week' },
          { name: 'Trending', slug: 'trending' },
          { name: 'Featured', slug: 'featured' }
        ]
      }
    });
  } catch (error) {
    console.error('Error getting categories:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to get categories',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}

/**
 * Create a new category
 */
export async function POST(request: Request) {
  try {
    const payload = await getPayload({ config: configPromise });
    
    // Handle both JSON and form data from Payload
    let data: any;
    const contentType = request.headers.get('content-type') || '';
    
    if (contentType.includes('application/json')) {
      data = await request.json();
    } else if (contentType.includes('application/x-www-form-urlencoded')) {
      const formData = await request.formData();
      data = {
        name: formData.get('name') as string,
        description: formData.get('description') as string,
        icon: formData.get('icon') as string,
      };
    } else {
      // Try to parse as text first, then as JSON
      const body = await request.text();
      try {
        data = JSON.parse(body);
      } catch {
        // If it's not JSON, treat it as form data
        const params = new URLSearchParams(body);
        data = {
          name: params.get('name'),
          description: params.get('description'),
          icon: params.get('icon'),
        };
      }
    }

    // Validate required fields
    if (!data?.name || typeof data.name !== 'string') {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Category name is required and must be a string' 
        },
        { status: 400 }
      );
    }

    // Create the category using Payload
    const category = await payload.create({
      collection: 'categories',
      data: {
        name: data.name.trim(),
        description: data.description || '',
        ...(data.icon && { icon: data.icon })
      }
    });

    return NextResponse.json({
      success: true,
      data: category
    });

  } catch (error) {
    console.error('Error creating category:', error);
    return NextResponse.json(
      { 
        success: false, 
        error: 'Failed to create category',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
